"use strict";(self.webpackChunkbabylonchain=self.webpackChunkbabylonchain||[]).push([[866],{3905:(e,t,n)=>{n.d(t,{Zo:()=>h,kt:()=>m});var a=n(7294);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function r(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,a,o=function(e,t){if(null==e)return{};var n,a,o={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var s=a.createContext({}),c=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):r(r({},t),e)),n},h=function(e){var t=c(e.components);return a.createElement(s.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},d=a.forwardRef((function(e,t){var n=e.components,o=e.mdxType,i=e.originalType,s=e.parentName,h=l(e,["components","mdxType","originalType","parentName"]),d=c(n),m=o,p=d["".concat(s,".").concat(m)]||d[m]||u[m]||i;return n?a.createElement(p,r(r({ref:t},h),{},{components:n})):a.createElement(p,r({ref:t},h))}));function m(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var i=n.length,r=new Array(i);r[0]=d;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l.mdxType="string"==typeof e?e:o,r[1]=l;for(var c=2;c<i;c++)r[c]=n[c];return a.createElement.apply(null,r)}return a.createElement.apply(null,n)}d.displayName="MDXCreateElement"},6076:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>r,default:()=>u,frontMatter:()=>i,metadata:()=>l,toc:()=>c});var a=n(7462),o=(n(7294),n(3905));const i={sidebar_label:"Babylon's solutions",sidebar_position:1,pagination_prev:null,pagination_next:null,custom_edit_url:null},r="Babylon's Solutions",l={unversionedId:"Babylon Summary",id:"Babylon Summary",title:"Babylon's Solutions",description:"Underlying Security Issues within Proof-of-Stake",source:"@site/docs/Babylon Summary.md",sourceDirName:".",slug:"/Babylon Summary",permalink:"/sample-docs/Babylon Summary",draft:!1,editUrl:null,tags:[],version:"current",sidebarPosition:1,frontMatter:{sidebar_label:"Babylon's solutions",sidebar_position:1,pagination_prev:null,pagination_next:null,custom_edit_url:null},sidebar:"tutorialSidebar"},s={},c=[{value:"Underlying Security Issues within Proof-of-Stake",id:"underlying-security-issues-within-proof-of-stake",level:2},{value:"1. Direct Checkpointing Limitation",id:"1-direct-checkpointing-limitation",level:2},{value:"2. Our Solution",id:"2-our-solution",level:2},{value:"3. Babylon Architecture",id:"3-babylon-architecture",level:2},{value:"3.1 Babylon BLS Signature Algorithm",id:"31-babylon-bls-signature-algorithm",level:3},{value:"3.2 Quorum Certificates (QC)",id:"32-quorum-certificates-qc",level:3},{value:"3.3 Babylon Vigilante Roles",id:"33-babylon-vigilante-roles",level:3},{value:"4. Key Design Features",id:"4-key-design-features",level:2},{value:"- BLS multiSig",id:"--bls-multisig",level:3},{value:"- Epoched validator set rotation",id:"--epoched-validator-set-rotation",level:3},{value:"- On-chain BTC oracle",id:"--on-chain-btc-oracle",level:3},{value:"- No change to Tendermint",id:"--no-change-to-tendermint",level:3},{value:"5. Babylon (BBL) Modules",id:"5-babylon-bbl-modules",level:2},{value:"5.1 Epoching Module",id:"51-epoching-module",level:3},{value:"5.2 Checkpointing Module",id:"52-checkpointing-module",level:3},{value:"5.3 OP_RETURN Oracle Module",id:"53-op_return-oracle-module",level:3},{value:"5.4 BTC_Header Oracle Module",id:"54-btc_header-oracle-module",level:3},{value:"5.5. Vigilante Master Monitor",id:"55-vigilante-master-monitor",level:3},{value:"<strong><em>Why is that so?</em></strong>",id:"why-is-that-so",level:4},{value:"7. The Cost",id:"7-the-cost",level:2}],h={toc:c};function u(e){let{components:t,...n}=e;return(0,o.kt)("wrapper",(0,a.Z)({},h,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"babylons-solutions"},"Babylon's Solutions"),(0,o.kt)("h2",{id:"underlying-security-issues-within-proof-of-stake"},"Underlying Security Issues within Proof-of-Stake"),(0,o.kt)("p",null,"Proof-of-stake (POS) is created as an alternative to Proof-of-work (POW), the original consensus mechanism used to validate a blockchain and add new blocks. Proof-of-stake uses a mechanism to where the cryptocurrency owners validate block transactions based on the number of staked coins. "),(0,o.kt)("p",null,"In POS, one voter can only vote for a maximum of one\nblock at height two. For instance, one voter can only vote for one\ncandidate when choosing a leader in an election.  For a block to be confirmed, it must receive 2/3 of the votes. A\nsupermajority vote is 2/3, while a majority vote is 51%. Therefore, if\n2/3 of the population votes, we declare that a block is confirmed."),(0,o.kt)("p",null,(0,o.kt)("img",{parentName:"p",src:"https://github.com/cahyosubroto/sample-docs/blob/main/image/image5.png?raw=true",alt:"Alt text"})),(0,o.kt)("p",null,"However, POS, by design, has security vulnerability if there are two forks and both blocks (seen in the figure above,\ncircled) have 2/3 of the votes. It will generate the total votes to be greater than 100%, or 133%.\nIt indicates that at least 33% of voters cast two votes, a practice known as a ",(0,o.kt)("strong",{parentName:"p"},"Double Signature Attack"),". This\ngoes against the protocol, which is not what it is intended to be."),(0,o.kt)("p",null,"The typical POS blockchain punish the double signature attackers by ",(0,o.kt)("strong",{parentName:"p"},"slashing")," them from\nthe chain. The attacker\\'s tokens and authority will be removed/slashed\nfrom the blockchain. If their double signature attacks are detected, it\nremoves the user\\'s tokens from the blockchain and their voting power in\nthe Proof of Stake system. However, the attackers may find a way to prevent the slashing and make\nslashing impossible for the chain. A few attacks are slashable, but a\nfew remain unslashable due to the attacker exploiting the inherent,\nfundamental security issue of Proof-of-Stake."),(0,o.kt)("p",null,"The attacker can resign from the network by ",(0,o.kt)("strong",{parentName:"p"},"unbonding")," to lose the\nmembership of the voting committee intentionally. In turn, their staked\ntokens will be returned along with their public key, private key, and\nother data, which they can trade freely now."),(0,o.kt)("p",null,(0,o.kt)("img",{parentName:"p",src:"https://github.com/cahyosubroto/sample-docs/blob/main/image/image8.png?raw=true",alt:"Alt text"})),(0,o.kt)("p",null,"When a voter withdraws its staked tokens, the voting committee will be\nreplaced by new members, and the old voter can now become an attacker by\ncreating a similar fork using the same keys. Upon observation, both\nchains will look similar. Now here comes the issue, since the voter has\nalready withdrawn their stakes from the original chain, they can't be\nslashed."),(0,o.kt)("p",null,"The voters can also sell their valid public keys; even after the sale,\nif they use their old keys. If the voter unlocks their token at block\n100 on height 2, as shown in the image above, they will have voting\npower because they are still voters with stacked tokens."),(0,o.kt)("p",null,"Imagine that this is done by 2/3 of the voters here who have resigned from\nthe chain. They can create a child block at height 2 and they can't be\nslashed. So, this is the fundamental security issue of POS chain systems\nthat cannot be resolved no matter how you modify the problem. Because\nthe foundation of a POS system is to let the user stake their tokens,\nbut people are surely entitled to resign and get their tokens back."),(0,o.kt)("p",null,"POS also have weak subjectivity vulnerability where it relies on the founding team or a cryptocurrency owners that staked the most coins to perform a check to detect any potential double signature attack on chain. This solution is a subjective solution and can create delays and potential human-error mistakes because people rely on human actors to tell them which fork to choose. There should be a better solution to check the chain objectively."),(0,o.kt)("h1",{id:""}),(0,o.kt)("h1",{id:"babylons-solution"},(0,o.kt)("strong",{parentName:"h1"},"Babylon's Solution:")),(0,o.kt)("p",null,"The issues discussed above are what we aim to tackle. The attack\nis only possible if people in the original chain have quit and there's a\ntemporal delay between the original and forked chains. The solution to detect and prevent the attack is by providing a trustworthy timestamp. However, the timestamps in\na blockchain block are meaningless since anybody may insert arbitrary\ntimestamps, so on-chain timestamps cannot be trusted."),(0,o.kt)("p",null,"Our solution provides a trustworthy timestamp to indicate when this block was\nproduced. It  So, for this purpose, we use ",(0,o.kt)("strong",{parentName:"p"},"Bitcoin")," as the\n",(0,o.kt)("strong",{parentName:"p"},"timestamping")," service. We use Bitcoin because it is the most secure blockchain in the\nworld. In Bitcoin, a fork can never be longer than 6\ndeep. If the latest block height is 1000, you can be sure that blocks 0\nto 994 will never be forked. Blocks 995, 996, and 997 may be forked, but\n994 and older will not be forked."),(0,o.kt)("p",null,(0,o.kt)("img",{parentName:"p",src:"https://github.com/cahyosubroto/sample-docs/blob/main/image/image3.png?raw=true",alt:"Alt text"})),(0,o.kt)("p",null,"This means that the checkpoint of any chain that appears after the 6\nblocks deep can be ignored. Suppose there are 6 blocks, as shown in the\nimage above, if we already see Block 6 there, we can safely say Block 2\nis confirmed. Because to create another fork, you must be faster than\nall existing miners to create the remaining blocks; this way, long-range\nPOS attacks can be avoided."),(0,o.kt)("h2",{id:"1-direct-checkpointing-limitation"},"1. Direct Checkpointing Limitation"),(0,o.kt)("p",null,"A POS chain can checkpoint its blocks to Bitcoin. But Bitcoin has a\nrestricted space and is pricey. It only allows 80 bytes of arbitrary\ndata per transaction. However, each checkpoint includes a 32-byte hash\nof the block and a signature to prevent attacks. Now, the signatures are\nlarge, and there are dozens or hundreds of votes that we need to\ncheckpoint. "),(0,o.kt)("p",null,"It will take at least a few kilobytes, and you can\\'t fit it\ninto a fair number of Bitcoin transactions. For 5000 bytes of data, we\nwill need at least 60 Bitcoin blocks to carry one checkpoint, which is\nboth pricey and abusive usage of Bitcoin, which is not welcomed."),(0,o.kt)("p",{align:"center"},(0,o.kt)("img",{src:"https://github.com/cahyosubroto/sample-docs/blob/main/image/image1.png?raw=true",alt:"drawing",width:"600"})),(0,o.kt)("h2",{id:"2-our-solution"},"2. Our Solution"),(0,o.kt)("p",{align:"center"},(0,o.kt)("img",{src:"https://github.com/cahyosubroto/sample-docs/blob/main/image/image2.png?raw=true",alt:"drawing",width:"600"})),(0,o.kt)("p",null,"To solve this, we add Babylon in the middle. So the PoS chains will send\ntheir checkpoints into Babylon, and inside the Babylon block, you will\nsee the checkpoints of the PoS chains. Then Babylon checkpoints its\nblocks to bitcoin. All the transactions, or the Babylon transactions,\ninside the Babylon blocks will have Bitcoin timestamps."),(0,o.kt)("p",null,(0,o.kt)("img",{parentName:"p",src:"https://github.com/cahyosubroto/sample-docs/blob/main/image/image9.png?raw=true",alt:"Alt text"})),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Babylon transactions")," are the checkpoints of the PoS chains. So the\nPoS chains will indirectly get Bitcoin timestamps by using Babylon.\nBabylon must protect itself since it is both a cosmic chain and a PoS\nchain. In front of BTC, Babylon serves as a load balancer, accepting the\nshared massive volume of data from the PoS chain."),(0,o.kt)("p",null,(0,o.kt)("img",{parentName:"p",src:"https://github.com/cahyosubroto/sample-docs/blob/main/image/image7.png?raw=true",alt:"Alt text"})),(0,o.kt)("p",null,"Babylon send checkpoints to Bitcoin and accepts checkpoints from many\nPoS chains. In the future, we want to allow the general public to\ncheckpoint their arbitrary data to Babylon. In the image above, between\nthe orange and blue, it\\'s intuitive. The blue block just sends your\ncheckpoints as Babylon transactions."),(0,o.kt)("br",null),(0,o.kt)("h2",{id:"3-babylon-architecture"},"3. Babylon Architecture"),(0,o.kt)("h3",{id:"31-babylon-bls-signature-algorithm"},"3.1 Babylon BLS Signature Algorithm"),(0,o.kt)("p",null,"We do not use just hashes for our POS blocks, we also use signatures\nso that not everyone can send in hashes and claim it as a Babylon\ncheckpoint. As the signatures are large, we do not use traditional\nsignature algorithms, we use BLS. The BLS signature can be aggregated\nand used to verify the merged signature."),(0,o.kt)("p",null,"For example, two signatures of 40 bytes each can be merged and formed\ninto one signature of 40 bytes. Similarly, the public keys can also be\nmerged into and used for verification. That means no matter how many\nvotes Babylon received, it can be aggregated into just one signature,\nwhich is only about 40 bytes."),(0,o.kt)("p",{align:"center"},(0,o.kt)("img",{src:"https://github.com/cahyosubroto/sample-docs/blob/main/image/image10.png?raw=true",alt:"drawing",width:"600"})),(0,o.kt)("p",null,"From the Babylon chain to BTC, we send a ",(0,o.kt)("strong",{parentName:"p"},"BLS multiSig")," and a\nbitcoin transaction called an ",(0,o.kt)("strong",{parentName:"p"},"op_return")," transaction that allows\nyou to carry some arbitrary data. The size of the checkpoint that\nBabylon sent to BTC is only about 150 bytes, which two Bitcoin\ntransactions can carry. Each Bitcoin transaction carries 80 bytes, and\ntwo transactions can carry 150 bytes for a checkpoint."),(0,o.kt)("h3",{id:"32-quorum-certificates-qc"},"3.2 Quorum Certificates (QC)"),(0,o.kt)("p",null,"Babylon use the BLS signature algorithm to generate ",(0,o.kt)("strong",{parentName:"p"},"Quorum\nCertificates (QC)"),". Technically, a quorum is a threshold number of\nvotes needed to certify a transaction as approved. A Quorum\nCertificate means the quorum community reaches a consensus and creates\nthe vote, which then becomes certified and has been approved."),(0,o.kt)("p",null,"The Quorum Certificate in Babylon is very small. It's only about 40\nbytes because we use the BLS signature algorithm to aggregate all the\nforks into one application code. This small amount of QC is the way to\nsolve the problem where the checkpoint is too large."),(0,o.kt)("h3",{id:"33-babylon-vigilante-roles"},"3.3 Babylon Vigilante Roles"),(0,o.kt)("p",null,"Vigilante means someone who voluntarily contribute to protect babylon.  Babylon has three vigilante roles who voluntarily contribute to the security of Babylon by uploading, downloading, and\nmonitoring work. Babylon will reward them through Babylon tokens."),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"Vigilante Submitter:")," who submits Babylon checkpoints to BTC."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"Vigilante Reporter:")," who scans the BTC and then reports back to\nthe Babylon chain."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"Vigilante Monitors:")," which compares the consistency between\nBitcoin and the Babylon chain.",(0,o.kt)("br",null),(0,o.kt)("br",null))),(0,o.kt)("h2",{id:"4-key-design-features"},"4. Key Design Features"),(0,o.kt)("p",null,(0,o.kt)("img",{parentName:"p",src:"https://github.com/cahyosubroto/sample-docs/blob/main/image/image4.png?raw=true",alt:"Alt text"})),(0,o.kt)("h3",{id:"--bls-multisig"},"- BLS multiSig"),(0,o.kt)("p",null,"Our BLS multiSig reduces the checkpoint size which allows our users to use our solution to secure their chains."),(0,o.kt)("h3",{id:"--epoched-validator-set-rotation"},"- Epoched validator set rotation"),(0,o.kt)("p",null,"In a standard PoS blockchain, you can subscribe as a staker to lock\nyour token and gain voting power at any time, and you can resign to\nreturn anytime. Whenever someone does this, the people who can vote\nchange."),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"For example"),", all the Babylon validators have locked half a million\nBabylon tokens. When you join the party, you lock 1,000,000 Babylon\ntokens in Babylon block 100. That means that in block 101, you will\ninstantly become a validator or voter with 1,000,000 votes."),(0,o.kt)("p",null,"You are not eligible to vote for Block 100, but you are eligible to\nvote for Block 101 because at Block 100 you submitted a request. That\nmeans that the validator set changes between 100 and 101."),(0,o.kt)("p",null,"We introduced a concept called ",(0,o.kt)("strong",{parentName:"p"},'\\"epoch\\"'),". Each epoch consists of,\nfor example, 500 Babylon blocks. Within these 500 Babylon blocks, the\nvalidator set cannot change."),(0,o.kt)("p",null,"Let's take the example of three validators. These validators make all\nthe decisions between blocks 1 to 499, any new validator is not\nallowed to join their party, and none of them can leave it. All these\n500 blocks are decided by those 3 validators. That means in order to\nhold them accountable for any attacks, we don\\'t have to checkpoint\nevery single block they have created; we only need to checkpoint the\nlast block. We only need to checkpoint once per hour and submit two\nBitcoin transactions."),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},(0,o.kt)("em",{parentName:"strong"},"Why do we set the number in the order of hundreds? Why not make it\nshorter than 100, or make it 1000, or 1 million?"))),(0,o.kt)("p",null,"If it is too short, it will cost us more because we will send more\ncheckpoints to Bitcoin. A smaller number is expensive, but it will\nprovide our users with a better experience because, for every epoch,\nwe will send the checkpoint. The checkpoint interval of half an hour to an hour is a reasonable\nchoice. If it is less than that, we can't afford it, and if it is too\nlong, then the users will need to wait too long."),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},"The more checkpoints we send, the earlier our users can get their\ntimestamps. If we send a timestamp every 5 minutes, our users will expect to receive a timestamp every five minutes. If we only send checkpoints every hour, our users will receive their timestamps once an hour.")),(0,o.kt)("h3",{id:"--on-chain-btc-oracle"},"- On-chain BTC oracle"),(0,o.kt)("h3",{id:"--no-change-to-tendermint"},"- No change to Tendermint"),(0,o.kt)("br",null),(0,o.kt)("h2",{id:"5-babylon-bbl-modules"},"5. Babylon (BBL) Modules"),(0,o.kt)("p",null,"We have some modules to achieve all these features internally. We have\nan epoching module inside the Babylon code base. No matter what language\nyou use to write the program, this program will consist of different\ncomponents and modules. They are wired into one program, and each module\ncorresponds to a thread or process within the program."),(0,o.kt)("p",null,(0,o.kt)("img",{parentName:"p",src:"https://github.com/cahyosubroto/sample-docs/blob/main/image/image11.png?raw=true",alt:"Alt text"})),(0,o.kt)("h3",{id:"51-epoching-module"},"5.1 Epoching Module"),(0,o.kt)("p",null,"The Babylon node is a binary executable; when you install it, you will\nbe running the Babylon node. The program has different threads inside,\nand the epoching module is one of them."),(0,o.kt)("p",null,"This module does not allow the validator set to change within the 500\nblocks. It will delay all the transactions that request to become\nvalidators until the end of the epoch - these requests will not be\nexecuted until the end of the epoch, so there's no change within the\nepoch."),(0,o.kt)("h3",{id:"52-checkpointing-module"},"5.2 Checkpointing Module"),(0,o.kt)("p",null,"The checkpointing module creates checkpoints in Bitcoin and manages\ntheir status, such as whether they are 6 deep enough, 10 deep, or 20\ndeep, and whether they are ready to be confirmed."),(0,o.kt)("h3",{id:"53-op_return-oracle-module"},"5.3 OP_RETURN Oracle Module"),(0,o.kt)("p",null,"The OP_RETURN Oracle is called an operator because the BTC transaction\nthat holds this is called an operator transaction."),(0,o.kt)("h3",{id:"54-btc_header-oracle-module"},"5.4 BTC_Header Oracle Module"),(0,o.kt)("p",null,"BTC Header Oracle logs the BTC header chain so that within the Babylon\nprogram, we know what the bitcoin chain looks like or how long it is."),(0,o.kt)("h3",{id:"55-vigilante-master-monitor"},"5.5. Vigilante Master Monitor"),(0,o.kt)("p",null,(0,o.kt)("img",{parentName:"p",src:"https://github.com/cahyosubroto/sample-docs/blob/main/image/image6.png?raw=true",alt:"Alt text"})),(0,o.kt)("p",null,"In Vigilante Master Monitor, the BTC light client will act as the master\nmonitor that will track the correctness of a BTC header oracle because\nthe Babylon nodes can't just directly talk to Bitcoin by themselves. The\ndifference between a full node and a light client is:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},(0,o.kt)("strong",{parentName:"p"},"A full node")," is a node that stores the entire blockchain,\nincluding the headers and blocks. It embodies all transactions and\nexecutes them.")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},(0,o.kt)("strong",{parentName:"p"},"A light client")," does not store the block or the transactions, nor\ndoes it execute them. A light client only stores the header. The\nheader is very small, and even if you have a very long blockchain,\nthe storage requirement is still quite minimal."))),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Example:")," If a Babylon node A asks its Bitcoin node about block 60,\nit may answer yes to A, but if B asks the same from its Bitcoin node, it\nmight get a negative answer."),(0,o.kt)("h4",{id:"why-is-that-so"},(0,o.kt)("strong",{parentName:"h4"},(0,o.kt)("em",{parentName:"strong"},"Why is that so?"))),(0,o.kt)("p",null,"Because they may have different network latencies. One node can be\nslower, and the other may be faster. That is why communicating with a\nBitcoin node separately may not give the same answer."),(0,o.kt)("p",null,"So that\\'s why we have a BTC header Oracle within the Babylon module to\nensure everyone sees the same Bitcoin chain. This BTC header chain of\ninformation is provided by the reporter, which we don\\'t trust. So we\nneed a monitoring program to ensure that what the reporter told us about\nBTC is the same as the real-world BTC."),(0,o.kt)("h2",{id:"7-the-cost"},"7. The Cost"),(0,o.kt)("p",null,"Each checkpoint will cost us about \\$2.00 per transaction. No matter how\nmany customers use Babylon, our cost will always be \\$2.00 per transaction."),(0,o.kt)("p",null,"When the PoS chains checkpoint to Babylon, they submit a Babylon\ntransaction to record the hash of the PoS chain block header. So this is\npacked into a Babylon transaction and sent to Babylon, but for the\nBabylon network to accept this transaction, you need to pay the\ntransaction fee."),(0,o.kt)("p",null,"The POS chains will pay Babylon, not in the form of a contract or\nsubscription fee. You pay a transaction fee, not a subscription. ",(0,o.kt)("strong",{parentName:"p"},"For\nexample,")," when you submit a transaction in Polygon, you must pay the\nPolygon nodes a transaction fee. Similarly, when you submit a Bitcoin\ntransaction, you pay Bitcoin miners a transaction fee. So, Babylon will\ncollect transaction fees for whatever data you checkpoint to it. The\nlarger the size, the higher the transaction fee."),(0,o.kt)("p",null,"Because Babylon is a decentralized system, there is no contract to sign.\nThere is no company behind Babylon. So our team will maintain the\nnetwork, but that doesn\\'t mean we own the network. All the community\nmembers and validators own the network. We can\\'t claim all the benefits\nor the income."))}u.isMDXComponent=!0}}]);